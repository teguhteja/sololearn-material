# 4. Dynamic Strings & Arrays

## Allocating Memory for Strings

When allocating memory for a string pointer, it's better to use `strlen` rather than the `sizeof` operator for calculating bytes.

Consider the following program:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
  char str20[20];
  char *str = NULL;

  strcpy(str20, "12345");
  printf("str20 size: %ld\n", sizeof(str20));
  printf("str20 length: %ld\n", strlen(str20));
  str = malloc(strlen(str20) + 1); /* make room for \0 */
  strcpy(str, str20);
  printf("%s", str);

  return 0;
}
```

This approach is better for memory management because you arenâ€™t allocating more space than is needed to a pointer. When using `strlen` to determine the number of bytes needed for a string, be sure to include one extra byte for the NULL character `\0`.

A `char` is always one byte, so there is no need to multiply the memory requirements by `sizeof(char)`.

**Run the code and see how it works!**

### Fill in the blanks to allocate 42 bytes for the `str` string:

```c
char *str = NULL;
str = malloc(42);
```

---

## Dynamic Arrays

Many algorithms implement a dynamic array because this allows the number of elements to grow as needed.

Since elements are not allocated all at once, dynamic arrays typically use a structure to keep track of the current array size, current capacity, and a pointer to the elements, as shown below:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int *elements;
  int size;
  int cap;
} dyn_array;

int main() {
  dyn_array arr;
  int i;

  /* initialize array */
  arr.size = 0;
  arr.elements = calloc(1, sizeof(*arr.elements));
  arr.cap = 1;  /* room for 1 element */

  /* expand by 5 more elements */
  arr.elements = realloc(arr.elements, (5 + arr.cap) * sizeof(*arr.elements));
  if (arr.elements != NULL)
    arr.cap += 5; /* increase capacity */

  /* add an element and increase size */  
  if (arr.size < arr.cap) {
    arr.elements[arr.size] = 50; /* add element to array */
    arr.size++;
  } else {
    printf("Need to expand array.");
  }

  /* display array elements */
  for (i = 0; i < arr.cap; i++)
    printf("Element %d: %d\n", i, arr.elements[i]);

  return 0;
}
```

### Expanding the array by more elements:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int *elements;
  int size;
  int cap;
} dyn_array;

int main() {
  dyn_array arr;
  int i;

  /* initialize array */
  arr.size = 0;
  arr.elements = calloc(1, sizeof(*arr.elements));
  arr.cap = 1;  /* room for 1 element */

  /* expand by 5 more elements */
  arr.elements = realloc(arr.elements, (5 + arr.cap) * sizeof(*arr.elements));
  if (arr.elements != NULL)
    arr.cap += 5; /* increase capacity */

  /* add an element and increase size */  
  if (arr.size < arr.cap) {
    arr.elements[arr.size] = 50; /* add element to array */
    arr.size++;
  } else {
    printf("Need to expand array.");
  }

  /* display array elements */
  for (i = 0; i < arr.cap; i++)
    printf("Element %d: %d\n", i, arr.elements[i]);

  return 0;
}
```

### Adding an element to the array increases its size:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int *elements;
  int size;
  int cap;
} dyn_array;

int main() {
  dyn_array arr;
  int i;

  /* initialize array */
  arr.size = 0;
  arr.elements = calloc(1, sizeof(*arr.elements));
  arr.cap = 1;  /* room for 1 element */

  /* expand by 5 more elements */
  arr.elements = realloc(arr.elements, (5 + arr.cap) * sizeof(*arr.elements));
  if (arr.elements != NULL)
    arr.cap += 5; /* increase capacity */

  /* add an element and increase size */  
  if (arr.size < arr.cap) {
    arr.elements[arr.size] = 50; /* add element to array */
    arr.size++;
  } else {
    printf("Need to expand array.");
  }

  /* display array elements */
  for (i = 0; i < arr.cap; i++)
    printf("Element %d: %d\n", i, arr.elements[i]);

  return 0;
}
```

The entire program is written in `main()` for demonstration purposes. To properly implement a dynamic array, sub-tasks should be broken down into functions such as `init_array()`, `increase_array()`, `add_element()`, and `display_array()`. Error checking was skipped to keep the demo short.

**Run the code and see how it works!**

---

### Fill in the blanks to allocate memory for an `int` array and then expand the memory for more elements:

```c
int *arr = malloc(4 * sizeof(int));
arr = realloc(arr, 8 * sizeof(int));
```
