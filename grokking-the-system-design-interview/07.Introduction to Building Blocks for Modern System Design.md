# Introduction to Building Blocks for Modern System Design

Learn how system design is like using Lego pieces to create larger, fascinating artifacts.

## We'll Cover the Following:
- The Bottom-Up Approach for Modern System Design
- Conventions

---

## The Bottom-Up Approach for Modern System Design

System design problems usually share similarities, though specific details are often unique. We have extracted these similarities as **basic building blocks** to be covered in this course. For example, a **load-balancing component** is a building block likely to be used in various design problems.

The purpose of separating the building blocks is to thoroughly discuss their design just once. This allows us to apply them later without revisiting the details. We can think of building blocks as bricks used to construct more effective, capable systems.

Many of the building blocks discussed are available for use in public clouds, such as **Amazon Web Services (AWS)**, **Azure**, and **Google Cloud Platform (GCP)**. While we won't construct a complete system in this course, learners are encouraged to explore this as an exercise.

### Using Building Blocks to Devise a Bottom-Up Approach for Designing Systems

We’ll discuss the following building blocks in detail:

1. **Domain Name System**: Design hierarchical and distributed naming systems for computers connected to the Internet via various protocols.

2. **Load Balancers**: Understand the design of load balancers that fairly distribute incoming client requests among a pool of servers, reducing load and bypassing failed servers.

3. **Databases**: Enable storage, retrieval, modification, and deletion of data. We’ll discuss database types, replication, partitioning, and distributed databases.

4. **Key-Value Store**: A non-relational database storing data as key-value pairs. We’ll explain the design of a key-value store with concepts like scalability, durability, and configurability.

5. **Content Delivery Network (CDN)**: Design a CDN to efficiently deliver viral content (videos, images, audio, webpages) to end users, reducing latency and burden on data centers.

6. **Sequencer**: Focus on designing a unique ID generator that maintains causality, explaining methods for generating unique IDs.

7. **Service Monitoring**: Critical for distributed systems, monitoring systems analyze performance and alert stakeholders of issues. We’ll design systems for server-side and client-side error monitoring.

8. **Distributed Caching**: Design a distributed caching system where multiple cache servers coordinate to store frequently accessed data.

9. **Distributed Messaging Queue**: Focus on designing a queue consisting of multiple servers, facilitating communication between producers and consumers, enhancing scalability and reliability.

10. **Publish-Subscribe System**: Design an asynchronous service-to-service communication method popular in serverless and microservices architectures.

11. **Rate Limiter**: Design a system that throttles incoming requests based on predefined limits, serving as a defensive layer to prevent excessive usage.

12. **Blob Store**: Focus on storage solutions for unstructured data, such as multimedia files and binary executables.

13. **Distributed Search**: A search system that returns relevant content from user queries. We’ll explore its three components: crawl, index, and search.

14. **Distributed Logging**: Design a logging system that allows efficient logging of events in a distributed environment, ensuring scalability and reliability.

15. **Distributed Task Scheduling**: Design a system that allocates resources to tasks to meet goals, often used for background processing.

16. **Sharded Counters**: Demonstrate an efficient distributed counting system to handle millions of concurrent read/write requests, like social media likes.

Building blocks are arranged topologically so that those depending on others appear later.

---

## Conventions

For elaboration, we’ll use a **“Requirements”** section whenever we design a building block (or design problem). The “Requirements” section will outline the expected deliverables from the developed design, divided into two sub-categories:

- **Functional Requirements**: Features available to users of the designed system (e.g., the ability to search for content using a search bar).
  
- **Non-Functional Requirements (NFRs)**: Criteria for usability, including high availability, low latency, scalability, etc.

Let’s start with our building blocks!