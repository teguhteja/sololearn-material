# 21. Derived Class Constructor & Destructor

### Inheritance

When inheriting classes, the base class's constructor and destructor are not inherited. However, they are called when an object of the derived class is created or destroyed. 

To further explain this behavior, let's create a sample class that includes a constructor and a destructor:

```cpp
class Mother {
 public:
  Mother() {
   cout <<"Mother ctor" << endl;
  }
  ~Mother() {
   cout <<"Mother dtor" << endl;
  }
};
```

Creating an object in the `main` function results in the following output:

```cpp
#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() {
            cout <<"Mother ctor"<< endl;
        }
        ~Mother() {
            cout <<"Mother dtor"<< endl;
        }
};

int main() {
    Mother m;
}
```

**Output:**
```
Mother ctor
Mother dtor
```

The object is created and then deleted when the program finishes running.

### Inheritance with Constructors and Destructors

Next, let's create a `Daughter` class, with its own constructor and destructor, and make it a derived class of the `Mother`:

```cpp
class Daughter: public Mother {
 public:
  Daughter() {
   cout <<"Daughter ctor" << endl;
  }
  ~Daughter() {
   cout <<"Daughter dtor" << endl;
  }
};
```

When we create a `Daughter` object, here’s what happens:

```cpp
#include <iostream>
using namespace std;

class Mother {
    public:
        Mother() {
            cout <<"Mother ctor" << endl;
        }
        ~Mother() {
            cout <<"Mother dtor" << endl;
        }
};

class Daughter: public Mother {
    public:
        Daughter() {
            cout <<"Daughter ctor" << endl;
        }
        ~Daughter() {
            cout <<"Daughter dtor" << endl;
        }
};

int main() {
    Daughter d;
}
```

**Output:**
```
Mother ctor
Daughter ctor
Daughter dtor
Mother dtor
```

**Explanation:**
- The base class constructor (`Mother()`) is called first.
- Then the derived class constructor (`Daughter()`) is called.
- When the object is destroyed, the derived class destructor (`~Daughter()`) is called first.
- Finally, the base class destructor (`~Mother()`) is called.

The derived class relies on the base class, so the base class is set up first and destroyed last.

---

### Destructors in `Game` and `Quiz` Classes

To implement destructors for both the `Game` and `Quiz` classes:

- Add a destructor to the `Game` class that outputs "Game Over".
- Add a destructor to the `Quiz` class that outputs "Quiz Over".
- Destructors are executed in reverse order: the derived class destructor (`Quiz`) is called first, followed by the base class destructor (`Game`).

Here’s the updated code:

```cpp
#include <iostream>
using namespace std;

class Game {
    public:
    // Constructor for Game class
    Game() {
        cout << "Game Started" << endl;
    }

    // Destructor for Game class
    ~Game() {
        cout << "Game Over" << endl;
    }
};

class Quiz: public Game {
    public:
    // Constructor for Quiz class
    Quiz() {
        cout << "Quiz Started" << endl;
    }

    // Destructor for Quiz class
    ~Quiz() {
        cout << "Quiz Over" << endl;
    }
};

int main() {
    Quiz q;  // Create an object of Quiz class
    return 0;  // Destructors will be automatically called when the object goes out of scope
}
```

**Example Output:**

```
Game Started
Quiz Started
Quiz Over
Game Over
```

### Key Points:
1. **Constructors**:
   - The base class constructor (`Game()`) is called first.
   - Then, the derived class constructor (`Quiz()`) is called.
   
2. **Destructors**:
   - When the object `q` of `Quiz` is destroyed, the derived class destructor (`~Quiz()`) is called first.
   - Then, the base class destructor (`~Game()`) is called.

---

### Inheritance Behavior Summary:

- **Constructors**: The base class constructor is called first when a derived class object is created.
- **Destructors**: The derived class destructor is called first when a derived class object is destroyed, followed by the base class destructor.

This sequence ensures that the base class is properly set up before the derived class is initialized, and the derived class is properly destroyed before the base class is deconstructed.

