# 24. Abstract Classes

## Virtual Functions
Virtual functions can also have their implementation in the base class:

```cpp
class Enemy {
 public:
  virtual void attack() {
   cout << "Enemy!" << endl;
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!" << endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!" << endl;
  }
};
```

Now, when you create an `Enemy` pointer and call the `attack()` function, the compiler will call the function that corresponds to the object's type the pointer points to:

```cpp
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() {
            cout << "Enemy!" << endl;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!" << endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!" << endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy e;

    Enemy *e1 = &n;
    Enemy *e2 = &m;
    Enemy *e3 = &e;

    e1->attack();  // Outputs "Ninja!"
    e2->attack();  // Outputs "Monster!"
    e3->attack();  // Outputs "Enemy!"
}
```

This is how **polymorphism** works. You have different classes with functions of the same name, same parameters, but different implementations.

---

## Pure Virtual Function
In some cases, you may want to include a virtual function in a base class to be redefined in derived classes, but with no meaningful definition in the base class. These are called **pure virtual functions**.

The syntax for defining a pure virtual function is by assigning `=0` after its declaration:

```cpp
class Enemy {
 public:
  virtual void attack() = 0;
};
```

The `=0` tells the compiler that the function has no body. The derived classes must provide their own implementation.

### Example of Pure Virtual Function:

```cpp
#include <iostream>
using namespace std;

class Enemy {
 public:
  virtual void attack() = 0;
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!" << endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!" << endl;
  }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
```

In this example, `attack()` is a **pure virtual function** that must be overridden in the derived classes, or the code will fail to compile.

---

### Exercise: Declaring a Pure Virtual Function

Fill in the blanks to declare a pure virtual function `sayHello()` in a `Person` class, and override it in the derived `Student` class:

```cpp
class Person {
public:
  virtual void sayHello() = 0;
};

class Student : public Person {
public:
  void sayHello() {
   cout << "Student says hello" << endl;
  }
};
```

---

## Abstract Classes
You **cannot** create objects of a base class that has a pure virtual function. These classes are called **abstract classes**.

Running the following code will produce an error:

```cpp
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!" << endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!" << endl;
        }
};

int main() {
    Enemy e;  // Error: cannot instantiate abstract class
    return 0;
}
```

An **abstract class** is a class that:
- Has at least one **pure virtual function**.
- Can only be used as a base class for inheritance, not for object instantiation.

### Example:

```cpp
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() = 0;
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!" << endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!" << endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();

    return 0;
}
```

In this example, objects of different derived classes (`Ninja` and `Monster`) are referred to using a unique type of pointer (`Enemy*`), and the proper member function is called each time due to **polymorphism**.

---

An **abstract class** is a class that:
- Has at least one **pure virtual function**.
