# 23. Virtual Functions

### Virtual Functions

The previous example demonstrates the use of base class pointers to the derived classes. Why is that useful? Continuing with our game example, we want every `Enemy` to have an `attack()` function.

To be able to call the corresponding `attack()` function for each of the derived classes using `Enemy` pointers, we need to declare the base class function as **virtual**.

Defining a virtual function in the base class, with a corresponding version in a derived class, allows polymorphism to use `Enemy` pointers to call the derived classes' functions.

Every derived class will override the `attack()` function and have a separate implementation:

```cpp
class Enemy {
 public:
  virtual void attack() {
  }
};

class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja!"<<endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster!"<<endl;
 }
};
```

A virtual function is a base class function that is declared using the keyword **virtual**.

Fill in the blanks to declare a virtual function named `attack()` for the `Enemy` class:

```cpp
class Enemy {
public:
  virtual void attack() {
     cout << "enemy attacks"; 
  }
};
```

### Virtual Functions in Action

Now, we can use `Enemy` pointers to call the `attack()` function.

```cpp
#include <iostream>
using namespace std;

class Enemy {
    public:
        virtual void attack() { }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja!" << endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster!" << endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->attack();
    e2->attack();
}
```

As the `attack()` function is declared **virtual**, it works like a template, allowing the derived class to override it with its own implementation.

Fill in the blanks to declare an `Enemy` class with a virtual `attack()` function, and then declare a `Ninja` class that inherits from `Enemy` and overrides its `attack()` function:

```cpp
class Enemy {
public:
  virtual void attack() { 
     cout << "Enemy attacks"; 
  }
};

class Ninja : public Enemy {
public:
  void attack() {
     cout << "Ninja attacks"; 
  }
};
```

### Virtual Functions and Polymorphism

Our game example serves to demonstrate the concept of **polymorphism**: we are using `Enemy` pointers to call the same `attack()` function, and generating different results.

```cpp
e1->attack();
e2->attack();
```

If a function in the base class is **virtual**, the function's implementation in the derived class is called according to the actual type of the object referred to, regardless of the declared type of the pointer.

A class that declares or inherits a virtual function is called a **polymorphic class**.

### Virtual Functions in the Zoo Example

To implement polymorphism correctly in this case, you need to add a **virtual function** for `speak()` in the base class `Animal`. This will allow the correct version of `speak()` (either from the `Dog` or `Cat` class) to be called at runtime, even when the object is accessed through an `Animal*` pointer.

Hereâ€™s how you can modify the code:

```cpp
#include <iostream>
using namespace std;

class Animal {
    public:
        string name;
        
        // Virtual function declaration
        virtual void speak() {
            cout << "Animal speaks!" << endl;
        }
};

class Dog: public Animal {
    public:
        void speak() override {  // Override keyword for clarity
            cout << "Woof!" << endl;
        }
};

class Cat: public Animal {
    public:
        void speak() override {  // Override keyword for clarity
            cout << "Meow!" << endl;
        }
};

int main() {
    Cat c1;
    c1.name = "Fluffy";
    Dog d1;
    d1.name = "Bingo";
    
    Animal *a1 = &c1;
    Animal *a2 = &d1;
    
    Animal* arr[] = {a1, a2}; 
    for(int i = 0; i < 2; i++) {
        arr[i]->speak();  // Polymorphism in action
    }

    return 0;
}
```

### Explanation of Changes:

1. **Virtual Function in `Animal`**: 
   - The `speak()` method in the `Animal` class is marked as `virtual`. This tells the compiler that this function may be overridden in derived classes (`Dog` and `Cat`).

2. **Override Keyword in Subclasses**:
   - The `speak()` method in `Dog` and `Cat` is marked with the `override` keyword to indicate that these methods are overriding the `speak()` method from the `Animal` class.

### Output:

When you run this program, it will correctly call the `speak()` method of the appropriate subclass (`Dog` or `Cat`), even though the objects are accessed through pointers of type `Animal*`.

```bash
Meow!
Woof!
```

This demonstrates **polymorphism**, where the correct method is called based on the actual object type (either `Dog` or `Cat`), not the pointer type (`Animal*`). 

