# 20. Protected Members

## Access Specifiers

So far, we have worked with **public** and **private** access specifiers:

- **Public members** can be accessed from anywhere outside of the class.
- **Private members** can only be accessed by their class or friend functions.

We’ve previously seen that it’s a good practice to use public methods to access private class variables.

### A Class' Public Members Are Available to:
- Everyone (outside the class).

### Protected Members

There is one more access specifier: **protected**. A **protected** member variable or function is similar to a **private** member, but with one key difference: it can be accessed in derived classes.

```cpp
class Mother {
 public:
  void sayHi() {
   cout << someVar;
  }

 private:
  int var = 0;

 protected:
  int someVar;
};
```

Now, `someVar` can be accessed by any class derived from the `Mother` class.

### What Does "Protected" Mean?
- Members are available to **derived class members**.

## Type of Inheritance

Access specifiers also define the **type of inheritance**. For example:

```cpp
class Daughter: public Mother
```

### Types of Inheritance:
1. **Public Inheritance**: 
   - Public members of the base class become public members of the derived class.
   - Protected members of the base class become protected members of the derived class.

2. **Protected Inheritance**: 
   - Public and protected members of the base class become protected members of the derived class.

3. **Private Inheritance**: 
   - Public and protected members of the base class become private members of the derived class.

If no access specifier is used, the type becomes **private** by default.

## Fixing Protected Member Access Issue

To fix the issue where a derived class needs to access private members of a base class, change the access specifier of the members from **private** to **protected**.

Here’s how you can modify the code:

1. **Change the access specifier of `price` and `weight` from `private` to `protected`.**
2. **Inherit the `Fruit` class from `Product` using `public` inheritance.**
3. **Call the `info()` method on the `Fruit` object.**

### Updated Code:

```cpp
#include <iostream>
using namespace std;

class Product {
    protected:
        double price;  // Protected access specifier
        int weight;    // Protected access specifier
    public:
        void info() {
            cout << price << ", " << weight << endl;
        }
};

// Inherit Fruit class from Product
class Fruit : public Product {
    public:
        string type;
        void setInfo(double p, int w) {
            price = p;
            weight = w;
        }
};

int main() {
    Fruit obj;
    obj.type = "Apple";
    obj.setInfo(4.99, 10);
    obj.info();
    
    return 0;
}
```

### Explanation:
1. **Protected Members**: The `price` and `weight` members in the `Product` class are now **protected**, meaning they are accessible in the `Fruit` class, which is derived from `Product`.
   
2. **Public Inheritance**: The `Fruit` class is inherited from `Product` using **public** inheritance, allowing `Fruit` to access the protected members of `Product`.

3. **Setting and Accessing Data**: The `setInfo()` method in the `Fruit` class sets the `price` and `weight`, and we call the `info()` method from the base class `Product` to display the data.

### Example Output:
```
4.99, 10
```

This ensures that the `Fruit` class can access the protected members from the `Product` class while maintaining encapsulation.

## Protected Member in Derived Class Example

To declare a **protected** member in the base class and access it from the derived class' `foo()` function:

```cpp
class Base {
 public:
    int baseVar;
};

class Derived : public Base {
 public:
    void foo() {
        baseVar = 12;  // Accessing baseVar from the derived class
    }
};
```

In this example, the `baseVar` is inherited as a **public** member, and it is accessed in the derived class function `foo()`.