# 22. Polymorphism

## Polymorphism
The word polymorphism means "having many forms". Typically, polymorphism occurs when there is a hierarchy of classes, and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different implementation to be executed depending on the type of object that invokes the function.

Simply, polymorphism means that a single function can have a number of different implementations.

### Briefly, polymorphism is...
- One implementation, with different functions
- Each implementation in a different function
- One function, with different implementations

## Example: Polymorphism in C++
Polymorphism can be demonstrated more clearly using an example:

Suppose you want to make a simple game, which includes different enemies: monsters, ninjas, etc. All enemies have one function in common: an `attack()` function. However, they each attack in a different way. In this situation, polymorphism allows for calling the same `attack()` function on different objects, but resulting in different behaviors.

### Step 1: Create the Enemy class
```cpp
class Enemy {
 protected: 
  int attackPower;
 public:
  void setAttackPower(int a) {
   attackPower = a;
  }
};
```

The `Enemy` class has a public method called `setAttackPower()`, which sets the protected `attackPower` member variable.

### Step 2: Create Ninja and Monster Classes
Our second step is to create classes for two different types of enemies, `Ninja` and `Monster`. Both of these new classes inherit from the `Enemy` class, so each has an `attackPower`. At the same time, each has a specific `attack()` function.

```cpp
class Ninja: public Enemy {
 public:
  void attack() {
   cout << "Ninja! - " << attackPower << endl;
  }
};

class Monster: public Enemy {
 public:
  void attack() {
   cout << "Monster! - " << attackPower << endl;
  }
};
```

As you can see, their individual `attack()` functions differ.

### Step 3: Use Polymorphism in the Main Function
Now we can create our `Ninja` and `Monster` objects in `main`.

```cpp
int main() {   
 Ninja n;
 Monster m;  
}
```

`Ninja` and `Monster` inherit from `Enemy`, so all `Ninja` and `Monster` objects are `Enemy` objects. This allows us to do the following:

```cpp
Enemy *e1 = &n;
Enemy *e2 = &m;
```

We've now created two pointers of type `Enemy`, pointing them to the `Ninja` and `Monster` objects.

### Example with Code
Now, we can call the corresponding functions:

```cpp
#include <iostream>
using namespace std;

class Enemy {
    protected: 
        int attackPower;
    public:
        void setAttackPower(int a) {
            attackPower = a;
        }
};

class Ninja: public Enemy {
    public:
        void attack() {
            cout << "Ninja! - " << attackPower << endl;
        }
};

class Monster: public Enemy {
    public:
        void attack() {
            cout << "Monster! - " << attackPower << endl;
        }
};

int main() {
    Ninja n;
    Monster m;
    Enemy *e1 = &n;
    Enemy *e2 = &m;

    e1->setAttackPower(20);
    e2->setAttackPower(80);

    n.attack();
    m.attack();
}
```

### Explanation:
We achieved the same result by calling the functions directly on the objects. However, it's faster and more efficient to use pointers.

Also, the pointer demonstrates that you can use the `Enemy` pointer without actually knowing that it contains an object of the subclass.

---

## Correcting a Similar Example

Here are the errors in the Coffee and Tea code and how to fix them:

1. **Inheritance Missing**: `Coffee` and `Tea` should inherit from the `Drink` class to be able to access the `price` attribute and the `setPrice()` method.
2. **Wrong Operator for Pointer Access**: You are trying to use `->` on objects `c` and `t`, but they are not pointers. The dot operator `.` should be used instead.
3. **Accessing Protected Attribute**: `price` is a protected member of the `Drink` class, so it can only be accessed within the class or by derived classes. The `make()` method in `Coffee` and `Tea` should have access to `price` if they inherit from `Drink`.

Here is the corrected code:

```cpp
#include <iostream>
using namespace std;

class Drink {
    protected: 
        int price;
    public:
        void setPrice(int a) {
            price = a;
        }
};

class Coffee : public Drink {  // Inherit from Drink
    public:
        void make() {
            cout << "Coffee: " << price << endl;
        }
};

class Tea : public Drink {  // Inherit from Drink
    public:
        void make() {
            cout << "Tea: " << price << endl;
        }
};

int main() {
    Coffee c;
    Tea t;
    Drink *e1 = &c;
    Drink *e2 = &t;

    e1->setPrice(5);  // Use pointer with -> operator
    e2->setPrice(6);  // Use pointer with -> operator

    c.make();  // Use . operator for objects
    t.make();  // Use . operator for objects
}
```

### Explanation of Fixes:
1. **Inheritance**: `Coffee` and `Tea` now inherit from `Drink`, allowing them to use the `setPrice()` method and the `price` attribute.
2. **Pointer Access**: For `e1` and `e2`, we use the `->` operator because they are pointers, while for objects `c` and `t`, the dot operator `.` is used.
3. **Polymorphism**: The `make()` function in both `Coffee` and `Tea` now accesses the `price` correctly since they inherit from `Drink`.

This should make the program work as expected.

---

### Fill in the Blanks:
Fill in the blanks to declare `Enemy` pointers to the `Ninja` and `Monster` objects. Set the `attackPower` of those objects via `Enemy` pointers, then call the `attack()` functions of both `Ninja` and `Monster` objects:

```cpp
Enemy* e1 = &ninjaObj;
Enemy* e2 = &monsterObj;
e1->setAttackPower(29);
e2->setAttackPower(99);
ninjaObj.attack();
monsterObj.attack();
```
