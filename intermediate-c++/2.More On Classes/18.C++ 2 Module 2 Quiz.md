# 18. C++ 2 Module 2 Quiz

### 1. Fill in the blanks to declare a destructor for the class `Student`:

```cpp
class Student {
 public:
  Student();
  ~Student(); // Destructor declaration
};
```

---

### 2. Fill in the blanks to declare a pointer to `st`, where `st` is of type `Student`, then call `printAge()` via the pointer:

```cpp
Student st;
Student *stPtr = &st;
stPtr->printAge();
```

---

### 3. Type in the missing keyword to declare a constant object of type `Person`:

```cpp
const Person obj;
```

---

### 4. For a class `P`, with one constant member named `weight` of type `double`, fill in the blanks to initialize `weight` in the constructor initializer list:

```cpp
P::P(double w) 
    : weight(w) 
{   
}
```

---

### 5. Select the keyword that will allow you to indicate that a function is a friend function for a class:

- **friend** (Correct Answer)

---

### 6. For a class `Test` with two private members named `mem` and `mem2`, fill in the blanks to print out their values in the `printValues()` function using the `this` keyword:

```cpp
void Test::printValues() {
    cout << this->mem;
    cout << this->mem2;
}
```

---

### 7. What is the keyword for overloading an operator in C++?

- **operator** (Correct Answer)

To implement the functionality of adding two queues together by overloading the `+` operator, we need to make sure that:

1. The `+` operator should return a new `Queue` object that contains the elements of both queues.
2. Elements of the first queue should come before the elements of the second queue in the resulting queue.

Here's the updated code:

```cpp
#include <iostream>
using namespace std; 

class Queue { 
	int size; 
	int* queue; 
	
	public:
	Queue() { 
		size = 0;
		queue = new int[100]; // Allocating enough space for the queue
	}

	void add(int data) { 
		queue[size] = data; 
		size++;
	}

	void remove() { 
		if (size == 0) { 
			cout << "Queue is empty" << endl; 
			return; 
		} 
		else { 
			for (int i = 0; i < size - 1; i++) { 
				queue[i] = queue[i + 1]; 
			} 
			size--; 
		} 
	} 

	void print() { 
		if (size == 0) { 
			cout << "Queue is empty" << endl; 
			return; 
		} 
		for (int i = 0; i < size; i++) { 
			cout << queue[i] << " <- ";
		} 
		cout << endl;
	}
	
	// Overloading the + operator to combine two queues
	Queue operator+(Queue &q) {
		Queue result;

		// Add elements from the first queue (this queue)
		for (int i = 0; i < this->size; i++) {
			result.add(this->queue[i]);
		}

		// Add elements from the second queue (q)
		for (int i = 0; i < q.size; i++) {
			result.add(q.queue[i]);
		}

		return result;
	}
}; 

int main() { 
	Queue q1; 
	q1.add(42); q1.add(2); q1.add(8); q1.add(1);

	Queue q2;
	q2.add(3); q2.add(66); q2.add(128); q2.add(5);

	// Add two queues together using the overloaded + operator
	Queue q3 = q1 + q2;
	q3.print();

	return 0; 
} 
```

### Explanation:
1. The `+` operator is overloaded by adding the `Queue operator+(Queue &q)` function.
2. Inside the overloaded function:
   - First, we create a new `Queue` object called `result`.
   - Then, we add all the elements from the first queue (`this` queue) to the `result`.
   - After that, we add all the elements from the second queue (`q`) to the `result`.
3. Finally, the `result` is returned, which is the combined queue.

### Output:
```
42 <- 2 <- 8 <- 1 <- 3 <- 66 <- 128 <- 5 <- 
``` 

This implementation ensures that the elements from the two queues are added in the correct order, with the first queue's elements appearing before the second queue's elements.
