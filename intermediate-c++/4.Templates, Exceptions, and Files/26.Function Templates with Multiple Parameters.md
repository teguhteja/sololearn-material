# 26. Function Templates with Multiple Parameters

## Function Templates
Function templates allow the creation of functions that work with multiple generic data types. You can define the data types using a comma-separated list.

Let's create a function that compares arguments of different data types (e.g., an `int` and a `double`) and prints the smaller one.

```cpp
template <class T, class U>
```

As you can see, this template declares two different generic data types, `T` and `U`.

### Fill in the blanks to declare the template function's parameters list. The template specification has two parameters named **T** and **U**.

```cpp
template
 <class T, 
class
 U>
```

## Function Templates

Now we can continue with our function declaration:

```cpp
template <class T, class U>
T smaller(T a, U b) {
  return (a < b ? a : b);
}
```

The ternary operator checks the `a < b` condition and returns the corresponding result. The expression `(a < b ? a : b)` is equivalent to the expression: *if `a` is smaller than `b`, return `a`, else return `b`*.

### Fill in the blanks to declare a template function **smaller** that takes two arguments and returns the smaller one. The arguments are of template types **F** and **S**, respectively.

```cpp
template
 <class F, 
class
 S>
F smaller(F a, S b)
{  
   return (a < b ? a : b); 
}
```

### Example: Using the Template Function in `main()`

```cpp
#include <iostream>
using namespace std;

template <class T, class U>
T smaller(T a, U b) {
    return (a < b ? a : b);
}

int main () {
    int x = 72;
    double y = 15.34;
    cout << smaller(x, y) << endl;
}
```

### Explanation
The output will be an integer because we specified the function template's return type to be of the same type as the first parameter (`T`), which is an integer.

### Modifying `myMax()` for Different Parameter Types

To modify the `myMax()` function so that it works with different parameter types, you can use two template parameters: one for each argument. The result should be of the type of the first parameter.

Here's the modified code:

```cpp
#include <iostream>
using namespace std;

// Change the function to accept different parameter types
template <class T1, class T2>
T1 myMax(T1 a, T2 b) {
    return (a > b ? a : b);
}

int main () {
    double x;
    int y;
    cin >> x >> y;
    cout << myMax(x, y) << endl;
}
```

### Explanation
- The template now accepts two different types (`T1` for the first parameter and `T2` for the second).
- The return type is still the type of the first parameter (`T1`).
- The function compares the two values and returns the greater one, automatically converting the second value to the first parameter's type if necessary. 

This allows the function to handle cases where the two parameters are of different types.

### Fill in the blanks to declare an integer variable and a double variable, and pass them to the template function **smaller**. Print the returned value to the screen.

```cpp
int main()
{
  int a = 12;
  double b = 23.7;
  cout << smaller(a, b) << endl;
}
```

### Function Templates: Custom Parameter Names

**T** is a common placeholder for *Type* in template declarations. However, you can use any name that makes sense for your code as long as it's not a C++ keyword.

Remember that when you declare a template parameter, you must use it in your function definition, or the compiler will throw an error!

### Quiz: Which statement about templates is true?

- Templates allow us to declare generic types of data.