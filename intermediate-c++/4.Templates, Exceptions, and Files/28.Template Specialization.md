# 28. Template Specialization

## Template Specialization

In regular class templates, the behavior of the class is uniform across different data types. However, template specialization allows for different implementations of a template when specific types are used. This is useful when you need to handle certain data types differently.

For example, handling `char` differently from other types:

### Regular Template Example

```cpp
template <class T>
class MyClass {
 public:
  MyClass(T x) {
    cout << x << " - not a char" << endl;
  }
};
```

### Specialization for `char`

To handle the `char` data type differently, we create a template specialization:

```cpp
template <>
class MyClass<char> {
 public:
  MyClass(char x) {
    cout << x << " is a char!" << endl;
  }
};
```

In the specialization, we use `template <>` to indicate that this is a specialization of the primary template, and `<char>` specifies that it is for the `char` type.

### Example Usage

```cpp
#include <iostream>
using namespace std;

template <class T>
class MyClass {
 public:
  MyClass(T x) {
    cout << x << " - not a char" << endl;
  }
};

template <>
class MyClass<char> {
 public:
  MyClass(char x) {
    cout << x << " is a char!" << endl;
  }
};

int main () {
    MyClass<int> ob1(42);
    MyClass<double> ob2(5.47);
    MyClass<char> ob3('s');
}
```

In this example:
- `MyClass<int>` and `MyClass<double>` use the generic template.
- `MyClass<char>` uses the specialized template, which handles characters differently.

## Template Specialization for `Div` Class

Here's how you can specialize the `Div` class to handle `string` types by outputting the division of the lengths of the strings:

### Primary Template for Numeric Types

```cpp
template <class T>
class Div {
 public:
  Div(T x, T y) {
    cout << x / y << endl;
  }
};
```

### Specialization for `string`

```cpp
template <>
class Div<string> {
 public:
  Div(string x, string y) {
    cout << x.size() / y.size() << endl;
  }
};
```

### Complete Example

```cpp
#include <iostream>
using namespace std;

// Primary template for numeric types
template <class T>
class Div {
 public:
  Div(T x, T y) {
    cout << x / y << endl;
  }
};

// Template specialization for strings
template <>
class Div<string> {
 public:
  Div(string x, string y) {
    // Output the division of the lengths of the strings
    cout << x.size() / y.size() << endl;
  }
};

int main () {
    string a, b;
    cin >> a >> b;
    int x, y;
    cin >> x >> y;
    
    Div<string> d2(a, b);  // Specialization for strings
    Div<int> d1(x, y);     // General template for integers
    
    return 0;
}
```

### Explanation

1. **Primary Template**: Handles numeric types with direct division.
2. **Template Specialization**: Handles `string` types by calculating the division of string lengths.

### Key Points

- **Specialization Syntax**: `template <>` for specialization.
- **Using `size()` Method**: For getting string lengths in the specialization.
- **Type-Specific Behavior**: The specialized template changes behavior for specific types.

## Declaring Objects with Template Parameters

Fill in the blanks to declare three objects of type `Spunky`:

```cpp
int main() {
  Spunky<int> i(4);      // Template parameter is integer
  Spunky<double> d(3.14); // Template parameter is double
  Spunky<char> ch('z');  // Template parameter is character
}
```

In this setup:
- `Spunky<int>` is used for integers.
- `Spunky<double>` is used for doubles.
- `Spunky<char>` is used for characters.


This markdown provides a detailed explanation and code for understanding template specialization and its usage in C++.