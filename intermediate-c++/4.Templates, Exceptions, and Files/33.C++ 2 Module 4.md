Drag and drop from the options below to declare a template function with two arguments of template type myT. The function returns the multiplication of its arguments.

<class myT>
myT mult(
a, myT b)
{
a * b;
}

Fill in the blanks to declare a template class ''MyClass'' with two template data members: ''first'' and ''second''. Initialize them in the constructor.

template
 <class T>
class
 MyClass
{
T first;
T 
second
;
public:
 MyClass(T a, T b) {
  first = a;
  second = b;
 }
};

Drag and drop from the options below to define the ''MyClass'' member function ''myFunc()'', where ''MyClass'' is a template class and ''myFunc'' prints "I love C++" to the screen.

<class T>
void MyClass
::myFunc()
{
<< "I love C++" << endl;
}

To specialize the `MyClass` template class for integers, you would need to use template specialization syntax. Hereâ€™s how you can fill in the blanks:

```cpp
template <>            // Empty angle brackets for specialization
class MyClass<int>     // Specializing the class for 'int'
{
public:
    MyClass(int x) {
        cout << x << endl;
    }
};
```

### Explanation:
1. **template <>**: This indicates template specialization, which means we are creating a version of the template specifically for `int`.
2. **MyClass<int>**: This specifies that this specialization is for the `int` type.

Now, this class is specialized for `int` and will behave accordingly when an object is instantiated with an `int` value.

Fill in the blanks to define a function ''myFunc'', which throws an exception with a value of ''99'', if its parameter is less than 0.

void myFunc(int arg)
{
try
 {
 if (arg < 0) 
throw
 99;
} 
except
 (int x) {
 cout << "error!" << endl;
 }
}

Which types can be used in the catch block of exceptions?

None
Integers and doubles only
Any type
Only integers

Rearrange to declare a file object ''fileObj'' and open a file named ''myfile.txt'' by calling the open() function on the ''fileObj'' object.

