# 27. Class Templates

## Class Templates

Just as we can define function templates, we can also define class templates, allowing classes to have members that use template parameters as types.

The same syntax is used to define the class template:

```cpp
template <class T>
class MyClass {

};
```

Just as with function templates, you can define more than one generic data type by using a comma-separated list.

Fill in the blanks to declare a template class `MyClass`.

```cpp
template <class T>
class MyClass { 
};
```

## Class Templates

As an example, let's create a class `Pair`, that will be holding a pair of values of a generic type.

```cpp
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b) : first(a), second(b) { }
};
```

The code above declares a class template `Pair`, with two private variables of a generic type, and one constructor to initialize the variables.

## Translate Course

Type to declare a template class `MyClass` with two template data members: `memOne` and `memTwo`. Initialize them in the constructor.

```cpp
template <class T>
class MyClass {
  T memOne;
  T memTwo;
public:
  MyClass(T a, T b) {
    memOne = a;
    memTwo = b;
  }
};
```

## Class Templates

A specific syntax is required in case you define your member functions outside of your class - for example in a separate source file.

You need to specify the generic type in angle brackets after the class name.

For example, to have a member function `bigger()` defined outside of the class, the following syntax is used:

```cpp
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b) : first(a), second(b) { }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  // some code
}
```

## Drag and Drop

Drag and drop from the options below to define a `MyClass` member function `hello()`, where `MyClass` is a template class, and `hello()` prints `Hi` to the screen.

```cpp
template <class T>
void MyClass<T>::hello() {
  cout << "Hi" << endl;
}
```

## Class Templates

The `bigger` function returns the greater value of the two member variables.

```cpp
template <class T>
class Pair {
 private:
  T first, second;
 public:
  Pair (T a, T b) : first(a), second(b) { }
  T bigger();
};

template <class T>
T Pair<T>::bigger() {
  return (first > second ? first : second);
}
```

The ternary operator compares the two variables, returning the greater one.

Fill in the blanks to define the `bigger` function:

```cpp
template <class T>
T MyClass<T>::bigger() {
  return (first > second ? first : second);
}
```

## Class Templates

To create objects of the template class for different types, specify the data type in angle brackets, as we did when defining the function outside of the class.

Here, we create a `Pair` object for integers.

```cpp
#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b) : first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first > second ? first : second);
}

int main() {
    Pair<int> obj(11, 22);
    cout << obj.bigger();

    return 0;
}
```

We can use the same class to create an object that stores any other type.

```cpp
#include <iostream>
using namespace std;

template <class T>
class Pair {
    private:
        T first, second;
    public:
        Pair (T a, T b) : first(a), second(b) { }
        T bigger();
};

template <class T>
T Pair<T>::bigger() {
    return (first > second ? first : second);
}

int main() {
    Pair<double> obj(23.43, 5.68);
    cout << obj.bigger();

    return 0;
}
```

To convert the `Queue` class into a template that supports different data types, we need to modify the class declaration and methods so they work for any type, not just integers.

The syntax to define a class template is `template <class T>`, where `T` represents the type parameter. You can use `T` throughout the class to refer to the type of elements stored in the queue.

Hereâ€™s how to modify the given code into a class template:

```cpp
#include <iostream>
using namespace std;

// Change the class to a template
template <class T>
class Queue 
{
    private:
        T *arr;  // Use T for the array type
        int count;
    public:
        Queue(int size) {
            arr = new T[size];  // Use T for array initialization
            count = 0;
        }
        void add(T elem) {  // Use T for the add method parameter
            arr[count] = elem;
            count++;
        }
        void get(int index) {
            cout << arr[index] << endl;
        }
};

int main() {
    Queue<string> q(4);  // Instantiate Queue with strings
    q.add("James");
    q.add("Andy");
    q.add("Amy");
    q.get(2);  // Output: Amy

    Queue<int> n(2);  // Instantiate Queue with integers
    n.add(42);
    n.add(33);
    n.get(1);  // Output: 33

    return 0;
}
```

### Explanation of Changes:
1. **Template Declaration**:  
   The line `template <class T>` makes the `Queue` class a template that can handle any data type `T`.

2. **Array Type**:  
   `T *arr;` declares an array that stores elements of type `T`.

3. **Constructor**:  
   The constructor dynamically allocates an array of type `T` to store the elements.

4. **`add` Method**:  
   The `add` method now takes a parameter of type `T` to allow adding elements of any type.

5. **`get` Method**:  
   The `get` method prints the element at the specified index, which is of type `T`.

Now the class works with both strings and integers, as shown in the `main()` function.

### Output:
```
Amy
33
```

Fill in the blank to declare the `MyClass` object with `integer` as its template parameter.

```cpp
MyClass<int> obj;
```
